数据双向绑定：
	DOM元素>data
	data>DOM元素
	

DOM元素>data的数据绑定
	目的：操作可输入数据的DOM元素【input type="text“，textarea,select】，导致对应的data的数据变化
	实现原理：元素的change事件，给事件同意添加预处理事件，获取修改的内容，然后同步到data中去

data>DOM元素的数据绑定
	目的：修改data的时候，和data相关联的DOM元素也对应更改
	实现方法：(多种实现)
		1.脏值检查（setTimeout检测数据变化,在angular的框架中用到）
		2.数据劫持：例如vue使用的Object.defineProperty()
	实现思路【数据劫持】：
		1.DOM元素的属性和data如何映射绑定（需要一个映射绑定的方法）：观察者模式
			观察者模式：
				观察者：template片段，更直接地说就是有v-bind属性的节点（每个节点有对应的callback，其实就是重新render）
				被观察者：data数据（被观察者中包含一个订阅数组，里面放了所有的观察者的订阅）

			具体执行流程：
				1.观察者订阅被观察者的某个key（订阅的时候观察者传入自己的回调函数）【有v-bind属性的节点为观察者，观察的key就是v-bind属性中的变量】
				2.被观察者里面的key的值变化的时候【也就是属性的set函数执行的时候】，在被观察者的订阅数组里面，遍历寻找哪几个观察者订阅了这个key，然后执行订阅这个key的观察者所传过来的回调函数

			优化：
				一次操作只改变一个key（不管改变的是string这种简单类型还是object复杂类型），修改后就直接执行对应的callback
				但是，很多情况下，比如说for循环，改变了许多key，因为for循环的js执行很快，而且其实改变的都是同一个父节点下的key，每个key改变就执行回调是很浪费的事情
				可以在set的时候【或者是在中间层内】，设置一个setTimeout，等js执行完，给所有的key寻找一个统一的父节点，然后再渲染





执行流程：
	1. monitor=new Observer({});//创建数据监听对象
	2. monitor.monit(data);//监控data数据，data数据一旦变更，就会触发观察者的发布事件：observer.publish(变化的属性名称)
	3. new Compile({//根据template和data创建了dom节点，最后把节点插入wrapper；创建的dom节点和所有子节点，监听他们的v-data属性，该属性v-data和data做了绑定，只要data改变，包含该属性的dom节点就会对应变更；
		wrapper:"body",
		data:{},
		template:""
	});//创建元素

	3.修改data中的属性，会触发observer.publish(变化的属性名称)，该事件会寻找绑定该属性的所有dom节点，然后修改dom重新渲染【其中用了文档碎片，提升性能呢】;
	4.优化，因为每个属性修改，都会触发observer.publish，然后再遍历所有有添加监听的dom节点，这个过程比较烦





数据双向绑定：view和model之间的绑定

view：视图，说白了就是html中dom节点的展示
model：数据模型，说白了就是js中的数据对象

view ---> model绑定：修改dom元素（input,textarea,select）的数据，导致model产生变化，只要给dom元素绑定change事件，触发事件的时候修改model即可，不细讲
model ---> view绑定：修改model数据，从而让dom元素产生改变，导致页面重新渲染

model ---> view绑定的方法：1.发布订阅模式（例如backbone.js）；2.数据劫持(vue.js)；3.脏检查(angular.js) 

下面写了个简单的demo，借鉴自vue.js,详细说明如何用“发布订阅模式+数据劫持”实现model到view的数据绑定

1.Observer ：观察者模式类，1.添加对数据的监控，2.订阅+发布
2.Compile ：模板编译器，1.根据模板生成dom树，2.给所有绑定了{{data}}的dom节点添加订阅事件（subscribe）
3.VM：ViewModel，把Observer和Compile结合在一起，生成dom树，并完成model ---> view绑定







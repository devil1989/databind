
数据双向绑定：
	定义：view和model之间的绑定
	目的：提高开发效率，统一处理数据，便于产品维护升级等
	备注：一般数据单向绑定即可（model ---> view绑定），数据双向绑定容易出现循环绑定问题，例如model改变导致view改变，
	     view改变又会导致model改变，如果处理不当容易导致无限循环；处理这种循环绑定，提升了框架复杂度。

view：视图，说白了就是html中dom树的展示
model：数据模型，说白了就是js中的数据对象,例如var data={persong：{sex:"",age:"",name:""},from:""}

view ---> model绑定：
	修改dom元素（input,textarea,select）的数据，导致model产生变化，只要给dom元素绑定change事件，触发事件的时候修改model即可，不细讲


model ---> view绑定：
	目的：修改model数据，导致dom元素产生改变，页面重新渲染
	方法：1.发布订阅模式（backbone.js用到）；2.数据劫持(vue.js用到)；3.脏值检查(angular.js用到) 




上面的说得很笼统，下面写了个简易的demo，通过demo说明下如何实现model ---> view绑定，整个demo的js不超过300行，仅支持template里面的{{data}}解析绑定
我的项目git地址：https://github.com/devil1989/databind 【为了防止世界被破坏，为了守护世界的和平，贯彻爱与真实的邪恶.... 请轻点喷】


简易思路（基于发布订阅模式和数据劫持）：
		1.通过defineProperty来监控model中的所有属性（对每一个属性都监控）
		2.编译template生成DOM树，如果dom节点和model需要绑定（例如<div id="{{model.name}}"></div>）,
		  就给这个名称为“model.name”的key绑定对应的function，funciton用于操作上面这个dom节点
		3.修改model.name的时候，会自动触发属性的set事件，set事件里面调用第2步中的绑定function

//demo start
如何使用：new VM({data:data,template:template});//传入数据和模板即可
	<!DOCTYPE html>
	<html lang="en">
	<head>
		<meta charset="UTF-8">
		<title>Document</title>
		<link rel="stylesheet" type="text/css" href="demo.css">
		<script type="text/javascript" src="./observe.js"></script>
	</head>
	<body>
		<template id="inner" type="text/template">
			<!-- 只支持单个属性，不支持函数计算-->
			<div title="{{des}}">
				<div>
					<ul id="list">
						<li >
							<span >age:</span>
							<input  type="text" name="" value="{{age}}" >
							<span id="age" style="float: left;">+</span>
						</li>
						<li>
							<span>name:</span>
							<input type="text" name="" value="{{name}}">
						</li>
					</ul>
				</div>
				
			</div>
		</template>

		<script type="text/javascript">
			(function(){
				window.data={name:"jeffrey",age:28,des:"测试"};
				var vm=new VM({
					data:data,
					template:document.getElementById("inner").innerHTML
					// wrapper:document.body//可以指定对应容器，也可以不指定容器，直接获取元素，再手动插入对应dom元素
				});
				document.body.appendChild(vm.get());

				document.getElementById("age").addEventListener("click",function(){
					data.age++;
				});
			})();
		</script>
	</body>
	</html>



详细说明：

	1.Observer (发布订阅模式+数据监控)：

		功能: “监控model", "订阅", "发布"
		
		
		函数和数组说明：
			Observer中的this.subs数组：包含了所有观察者，每个观察者的结构如下：
				{
					//这个key代表model.person.age.range这个属性
					key："person.age.range"

					//和key绑定的函数数组，每个函数操作一个dom节点，一个key对应多个dom节点，所以actionList是个function数组；
					actionList：[function(){},function(){}]
				}

			monit方法【监控】：遍历model中所有的属性，每个属性用defineKey来监控所有属性

			defineKey方法：用到了Object.defineProperty来定义属性，这样属性改变的时候，就会自动执行里面的set方法

			defineKey里面的set方法：更新并监控新的值，执行publish函数（publish函数会根据这个key来执行所有绑定的function）

			subscribe方法【订阅】：给model中的某个key（例如person.age.range)添加绑定的function ； subscribe是在遍历dom节点的时候添加的

			publish方法【发布】：根据key来执行绑定在这个key上的所有函数，比如说person.age.range这个key，它变动的时候，
							  publish会执行绑定在person.age.range这个key上所有的function
		

		
		部分源码如下：
			var Observer = function(opts) {
				this.id = (opts && opts.id) ? opts.id : +new Date();
				this.opts = opts;
				this.subs = []; //观察者数组
			}
			Observer.prototype = {

				//监控数据
				monit: function(data, baseUrl) {
					var me = this;
					baseUrl = baseUrl || "";
					var isTypeMatch = (data && typeof data === "object");
					if (isTypeMatch) {
						Object.keys(data).forEach(function(key) {
							var base = baseUrl ? (baseUrl + "." + key) : key;
							me.defineKey(data, key, data[key], baseUrl); //定义自己
							me.monit(data[key], base); //递归【定义的是下一层】
						});
					}
				},

				//定义数据
				defineKey: function(data, key, val, baseUrl) {
					var me = this;
					var base = baseUrl ? (baseUrl + "." + key) : key;

					Object.defineProperty(data, key, {
						enumerable: true,
						configurable: false,
						get: function() {
							return val;
						},
						set: function(newVal) {
							if (newVal !== val) {
								val = newVal;

								//设置新值需要重新监控
								me.monit(newVal, base); 

								//(baseUrl+"."+key)作为观察者模式中的监听的那个key，也可以说是监听的那个事件
								me.publish(base, newVal); 
							}
						}
					});
				},

				//发布
				publish: function(key, newVal) {
					(this.subs || []).forEach(function(sub) {
						if (sub.key == key) {
							(sub.actionList || []).forEach(function(action) {
								action(newVal);
							});
						}
					});
				},

				//订阅
				subscribe: function(key, callback) {
					var tgIdx;
					var hasExist = this.subs.some(function(unit, idx) {
						tgIdx = (unit.key === key) ? idx : -1;
						return (unit.key === key)
					});
					if (hasExist) {
						if (Object.prototype.toString.call(this.subs[tgIdx].actionList) === "[object Array]") {
							this.subs[tgIdx].actionList.push(callback);
						} else {
							this.subs[tgIdx].actionList = [callback];
						}
					} else {
						this.subs.push({
							key: key,
							actionList: [callback]
						});
					}
				},

				//取消订阅
				remove: function(key) {
					var removeIdx;
					this.subs.forEach(function(sub, idx) {
						removeIdx = sub.key === key ? idx : -1;
						return sub.key === key
					});
					if (removeIdx !== -1) {
						this.subs.splice(removeIdx, 1);
					}
				}
			};


	2.Compile (模板编译器)：
		功能： “根据模板生成dom树"，"所有绑定了model属性的dom节点执行订阅函数（Observer.prototype.subscribe）”

		函数说明：
			transToFrament：把页面上的dom节点转化成文档碎片，防止dom频繁操作影响页面性能
			travelAllNodes：遍历文档碎片节点下所有的node节点（用到了函数递归调用）,执行compileNode
			compileNode：根据不同类型来编译node节点,例如compileTextNode，
			compileTextNode：把节点中的"{{key}}"替换成对应的值，同时执行bindKeyToNode
			bindKeyToNode：执行Observer中的subscribe【订阅】操作

		部分源码如下：
			var Compile = function(opts) {
				...
			};
			Compile.prototype = {
				...

				//把原有节点转化成Frament节点，createDocumentFragment创建文档碎片节点，不会导致页面渲染
				transToFrament: function(el) {
					var fragment = document.createDocumentFragment(),
						child;
					// 将原生节点拷贝到fragment
					while (child = el.firstChild) {
						fragment.appendChild(child);
					}
					return fragment;
				},

				//遍历所有节点
				travelAllNodes: function(ele) {
					this.compileNode(ele);
					([].slice.call(ele.childNodes) || []).forEach(function(node) {
						this.compileNode(node);
						if (node.childNodes && node.childNodes.length) {
							this.travelAllNodes(node);
						}
					}.bind(this));
				},

				/*包含功能
				 1.渲染node节点
				 2.给key设置callback函数，函数内操作node节点
				 */
				compileNode: function(node) {
					if (this.isElement(node)) {
						this.compileElementNode(node);
					} else if (this.isText(node)) {
						this.compileTextNode(node);
					}
				},

				//编译文本类型的node节点，里面放了对应的"{{data.name}}"这种数据格式
				compileTextNode: function(ele) {
					var key = this.getKey(ele.textContent);
					this.bindKeyToNode(key, ele);
					ele.textContent = this.compileString(ele.textContent);
				},

				//绑定key和node节点，key一旦改变，就会触发对应的函数，修改node节点
				bindKeyToNode: function(key, node) {
					if (!!key.trim()) {
						console.log(key);
						var nodeType = node.nodeType;
						var regExp = new RegExp("\\{\\{" + key + "\\}\\}");
						var originTextConetnt;
						if (nodeType === 2) {
							originTextConetnt = node.value;
						} else if (nodeType === 3) {
							originTextConetnt = node.textContent;
						}

						this.observer.subscribe(key, function(newVal) {
							var tgValue = originTextConetnt.replace(regExp, newVal);
							if (nodeType === 2) {
								node.value = tgValue;
							} else if (nodeType === 3) {
								node.textContent = tgValue;
							}
						});
					}
				}
				...
			}


	3.VM：ViewModel，作为数据单向绑定的入口类，该类把Observer和Compile结合在一起，完成model ---> view绑定，最终生成dom树并渲染
		

		具体源码如下：
		var VM = function(opts) {
			this.opts = opts;
			this.data = opts.data;
			this.wrapper = opts.wrapper;
			this.template = opts.template;
			this.Observer = (typeof Observer != undefined) ? Observer : opts.Observer;
			this.Compile = (typeof Compile != undefined) ? Compile : opts.Compile;
			this.init();
		}

		VM.prototype = {
			init: function() {
				var opts = this.opts;
				this.observer = new this.Observer(opts);
				this.observer.monit(this.data); //监控数据变化，数据已经改变了
				this.compiler = new this.Compile(Object.assign(opts, {
					observer: this.observer
				})); //编译生成节点
				if (this.wrapper) {
					this.wrapper.appendChild(this.compiler.getElement());
				}
			},
			get: function() {
				return this.compiler.getElement();
			}
		};



	整体地梳理一遍这个demo的执行流程：
	1.new VM({data:data,template:template}),传入的data就是model，传入的template用于生成dom树（也就是view），完成了model到view的绑定
	2.VM.prototype.init：
		2.1 创建数据监控对象this.observer，该对象监控data（监控以后，data的属性改变，就会执行defineProperty中的set函数，set函数里面添加了publish发布函数）

		2.2 创建模板编译器对象this.compiler，该对象编译template，生成最终的dom树，并且给每个需要绑定数据的dom节点添加了subscribe订阅函数

		2.3 最后，改变data里面的属性，会自动触发defineProperty中的set函数，set函数调用publish函数，publish会根据key的名称，
		   找到对应的需要执行的函数列表，依次执行所有函数（这些函数是在2.2步中，通过subscribe添加到key上的）






